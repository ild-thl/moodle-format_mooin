{"version":3,"file":"section.min.js","sources":["../../../src/local/content/section.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Course section format component.\n *\n * @module     core_courseformat/local/content/section\n * @class      core_courseformat/local/content/section\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Header from \"format_mooin4/local/content/section/header\";\nimport DndSection from \"format_mooin4/local/courseeditor/dndsection\";\nimport Templates from \"core/templates\";\nimport ModalFactory from \"core/modal_factory\";\nimport Mooin4Modal from \"../../mooin4modal\";\nimport { get_string as getString } from \"core/str\";\nimport ILD from \"format_mooin4/ildhvp4\";\n\nexport default class extends DndSection {\n  /**\n   * Constructor hook.\n   */\n  create() {\n    // Optional component name for debugging.\n    this.name = \"content_section\";\n    // Default query selectors.\n    this.selectors = {\n      SECTION_ITEM: `[data-for='section_title']`,\n      CM: `[data-for=\"cmitem\"]`,\n      SECTIONINFO: `[data-for=\"sectioninfo\"]`,\n      SECTIONBADGES: `[data-region=\"sectionbadges\"]`,\n      SHOWSECTION: `[data-action=\"sectionShow\"]`,\n      HIDESECTION: `[data-action=\"sectionHide\"]`,\n      SETCHAPTER: `[data-action=\"sectionSetChapter\"]`,\n      UNSETCHAPTER: `[data-action=\"sectionUnsetChapter\"]`,\n      ACTIONTEXT: `.menu-action-text`,\n      ICON: `.icon`,\n      H5P: `.parent-iframe`,\n    };\n    // Most classes will be loaded later by DndCmItem.\n    this.classes = {\n      LOCKED: \"editinprogress\",\n      HASDESCRIPTION: \"description\",\n      HIDE: \"d-none\",\n      HIDDEN: \"hidden\",\n      CHAPTER: \"chapter\",\n    };\n\n    // We need our id to watch specific events.\n    this.id = this.element.dataset.id;\n  }\n\n  /**\n   * Initial state ready method.\n   *\n   * @param {Object} state the initial state\n   */\n  stateReady(state) {\n    this.configState(state);\n    // Drag and drop is only available for components compatible course formats.\n    if (this.reactive.isEditing && this.reactive.supportComponents) {\n      // Section zero and other formats sections may not have a title to drag.\n      const sectionItem = this.getElement(this.selectors.SECTION_ITEM);\n      if (sectionItem) {\n        // Init the inner dragable element.\n        const headerComponent = new Header({\n          ...this,\n          element: sectionItem,\n          fullregion: this.element,\n        });\n        this.configDragDrop(headerComponent);\n      }\n    }\n    this._showLastSectionModal(state);\n    this._hvpListener();\n  }\n\n  /**\n   * Component watchers.\n   *\n   * @returns {Array} of watchers\n   */\n  getWatchers() {\n    return [\n      { watch: `section[${this.id}]:updated`, handler: this._refreshSection },\n      // {watch: `section[${this.id}].sectionprogress:updated`, handler: this._updateSectionProgress}\n    ];\n  }\n\n  /**\n   * Validate if the drop data can be dropped over the component.\n   *\n   * @param {Object} dropdata the exported drop data.\n   * @returns {boolean}\n   */\n  validateDropData(dropdata) {\n    // If the format uses one section per page sections dropping in the content is ignored.\n    if (dropdata?.type === \"section\" && this.reactive.sectionReturn != 0) {\n      return false;\n    }\n    return super.validateDropData(dropdata);\n  }\n\n  /**\n   * Get the last CM element of that section.\n   *\n   * @returns {element|null}\n   */\n  getLastCm() {\n    const cms = this.getElements(this.selectors.CM);\n    // DndUpload may add extra elements so :last-child selector cannot be used.\n    if (!cms || cms.length === 0) {\n      return null;\n    }\n    return cms[cms.length - 1];\n  }\n\n  /**\n   * Update a content section using the state information.\n   *\n   * @param {object} param\n   * @param {Object} param.element details the update details.\n   */\n  _refreshSection({ element }) {\n    // Update classes.\n    this.element.classList.toggle(\n      this.classes.DRAGGING,\n      element.dragging ?? false\n    );\n    this.element.classList.toggle(this.classes.LOCKED, element.locked ?? false);\n    this.element.classList.toggle(\n      this.classes.HIDDEN,\n      !element.visible ?? false\n    );\n    this.element.classList.toggle(\n      this.classes.CHAPTER,\n      element.isChapter ?? false\n    );\n    this.locked = element.locked;\n    // The description box classes depends on the section state.\n    const sectioninfo = this.getElement(this.selectors.SECTIONINFO);\n    if (sectioninfo) {\n      sectioninfo.classList.toggle(\n        this.classes.HASDESCRIPTION,\n        element.hasrestrictions\n      );\n    }\n    // Update section badges and menus.\n    this._updateBadges(element);\n    this._updateActionsMenu(element);\n\n    if (this.reactive.isEditing) {\n      //this._reloadSectionNames({ element: element });\n    }\n  }\n\n  async _reloadSectionNames({ element }) {\n    const title = this.getElement(this.selectors.SECTION_ITEM);\n    //window.console.log(element);\n    if (!element.isChapter) {\n      //title.innerHTML = element.parentChapter + \".\" + element.innerChapterNumber + \": \" + element.title;\n      title.innerHTML = element.prefix;\n    }\n  }\n\n  /**\n   * Update a section badges using the state information.\n   *\n   * @param {object} section the section state.\n   */\n  _updateBadges(section) {\n    const current = this.getElement(\n      `${this.selectors.SECTIONBADGES} [data-type='iscurrent']`\n    );\n    current?.classList.toggle(this.classes.HIDE, !section.current);\n\n    const hiddenFromStudents = this.getElement(\n      `${this.selectors.SECTIONBADGES} [data-type='hiddenfromstudents']`\n    );\n    hiddenFromStudents?.classList.toggle(this.classes.HIDE, section.visible);\n  }\n\n  /**\n   * Update a section action menus.\n   *\n   * @param {object} section the section state.\n   */\n  async _updateActionsMenu(section) {\n    let selector;\n    let newAction;\n    if (section.visible) {\n      selector = this.selectors.SHOWSECTION;\n      newAction = \"sectionHide\";\n    } else {\n      selector = this.selectors.HIDESECTION;\n      newAction = \"sectionShow\";\n    }\n\n    if (section.isChapter) {\n      selector = this.selectors.SETCHAPTER;\n      newAction = \"sectionUnsetChapter\";\n    } else {\n      selector = this.selectors.UNSETCHAPTER;\n      newAction = \"sectionSetChapter\";\n    }\n\n    // Find the affected action.\n    const affectedAction = this.getElement(selector);\n    if (!affectedAction) {\n      return;\n    }\n    // Change action.\n    affectedAction.dataset.action = newAction;\n    // Change text.\n    const actionText = affectedAction.querySelector(this.selectors.ACTIONTEXT);\n    if (affectedAction.dataset?.swapname && actionText) {\n      const oldText = actionText?.innerText;\n      actionText.innerText = affectedAction.dataset.swapname;\n      affectedAction.dataset.swapname = oldText;\n    }\n    // Change icon.\n    const icon = affectedAction.querySelector(this.selectors.ICON);\n    if (affectedAction.dataset?.swapicon && icon) {\n      const newIcon = affectedAction.dataset.swapicon;\n      if (newIcon) {\n        const pixHtml = await Templates.renderPix(newIcon, \"core\");\n        Templates.replaceNode(icon, pixHtml, \"\");\n      }\n    }\n  }\n\n  async _showLastSectionModal(state) {\n    const section = state.section.get(this.id);\n    if (\n      section.showLastSectionModal &&\n      window.location.href == section.sectionurl.replace(/&amp;/g, \"&\")\n    ) {\n      const modal = await ModalFactory.create({\n        type: Mooin4Modal.TYPE,\n        title: await getString(\n          \"modal_last_section_of_chapter_title\",\n          \"format_mooin4\"\n        ),\n        body: Templates.render(\n          \"format_mooin4/local/content/modals/lastsection\",\n          {}\n        ),\n        footer: Templates.render(\n          \"format_mooin4/local/content/modals/modalfooterclose\",\n          {}\n        ),\n        scrollable: false,\n      });\n      modal.show();\n      modal.showFooter();\n      this.reactive.dispatch(\"setLastSectionModal\", this.id);\n    }\n  }\n\n  _hvpListener() {\n    var h5p_contentIds = [];\n    var parentIFrames = this.getElements(this.selectors.H5P);\n    //console.log(\"Anzahl der parentIFrames gefunden:\", parentIFrames.length);\n    if (parentIFrames.length > 0) {\n      parentIFrames.forEach((parentIFrame) => {\n        if (parentIFrame.contentDocument) {\n          var parentIFrameContent =\n            parentIFrame.contentDocument || parentIFrame.contentWindow.document;\n          //console.log(\"parentIFrameContent gefunden:\", parentIFrameContent);\n\n          let nestedIFrame = null;\n\n          const adjustParentIFrameHeight = () => {\n            setTimeout(() => {\n              console.log(\"adjustParentIFrameHeight\");\n\n              if (nestedIFrame && nestedIFrame.contentWindow.document.body) {\n                const nestedIFrameHeight =\n                  nestedIFrame.contentWindow.document.body.scrollHeight;\n                if (nestedIFrameHeight > 1) {\n                  parentIFrame.style.height = nestedIFrameHeight + \"px\";\n                  // console.log(\n                  //     \"ParentIFrame-Höhe angepasst:\",\n                  //     nestedIFrameHeight + \"px\"\n                  // );\n                } else {\n                  //console.log(\"Inhalt noch nicht vollständig gerendert, Höhe nicht angepasst.\");\n                }\n              } else {\n                //console.log(\"Body ist noch nicht verfügbar.\");\n              }\n            }, 100);\n          };\n\n          const monitorElementLoads = () => {\n            console.log(\"monitorElementLoads\");\n\n            // Überwache das Laden von Bildern, Videos und anderen Medien im iframe\n            const elementsToWatch = ['img', 'video', 'iframe', 'embed', 'object'];\n            elementsToWatch.forEach(tag => {\n              const elements = nestedIFrame.contentDocument.getElementsByTagName(tag);\n              for (let element of elements) {\n                element.addEventListener('load', adjustParentIFrameHeight);\n                element.addEventListener('resize', adjustParentIFrameHeight);\n              }\n            });\n          };\n\n          const checkForH5P = () => {\n            console.log(\"checkForH5P\");\n            if (nestedIFrame) {\n              var H5PIntegration = nestedIFrame.contentWindow.H5PIntegration;\n              var H5P = nestedIFrame.contentWindow.H5P;\n              if (H5P && H5P.externalDispatcher) {\n                //console.log(\"H5P-Objekt gefunden.\");\n\n                //workaround for problem, that several observer regard the same object\n                function addUniqueH5PcontentId(array, element) {\n                  if (!array.includes(element)) {\n                    array.push(element);\n                  }\n                  return array;\n                }\n\n                //array of h5p contentId\n\n                H5P.setFinished = function (contentId, score, maxScore, time) {\n                  // H5P-Funktion hijacken, damit die Grade nicht doppelt eingetragen wird\n                };\n\n                //H5P.externalDispatcher.on(\"xAPI\", this._hvpprogress.bind(this));\n                //ILD.checkLibrary();\n                //H5P.externalDispatcher.on(\"xAPI\", ILD.xAPIAnsweredListener);\n                if (!h5p_contentIds.includes(H5P.instances[0].contentId)) {\n                  var current_array = addUniqueH5PcontentId(h5p_contentIds, H5P.instances[0].contentId);\n                  ILD.init(H5P, H5PIntegration, this.id, this.reactive);\n                }\n                //window.console.log(H5P);\n\n                adjustParentIFrameHeight(); // Höhe sofort anpassen, wenn H5P gefunden wird\n\n                // Starte den MutationObserver\n                var observer = new MutationObserver(function (mutations) {\n                  mutations.forEach(function (mutation) {\n                    if (mutation.addedNodes.length > 0 || mutation.attributeName === 'src') {\n                      // console.log(\n                      //     \"DOM-Änderung oder Attributänderung erkannt im .h5p-iframe: \",\n                      //     mutation\n                      // );\n                      adjustParentIFrameHeight(); // Passe die Höhe nach der Mutation oder Attributänderung an\n                    }\n                  });\n                });\n\n                observer.observe(nestedIFrame.contentDocument, {\n                  childList: true,\n                  subtree: true,\n                  attributes: true, // Überwacht Änderungen an Attributen wie `src`\n                });\n                // console.log(\n                //     \"MutationObserver wurde gestartet, um Änderungen im .h5p-iframe zu überwachen.\"\n                // );\n\n                return true; // H5P wurde gefunden und alles eingerichtet\n              }\n            }\n            return false; // H5P wurde noch nicht gefunden oder nestedIFrame ist nicht verfügbar\n          };\n\n          const checkForNestedIFrame = () => {\n            nestedIFrame = parentIFrameContent.querySelector(\".h5p-iframe\");\n            //console.log(\"nestedIFrame gefunden:\", nestedIFrame);\n\n            if (nestedIFrame) {\n              // Füge ein 'load' Event hinzu\n              nestedIFrame.addEventListener('load', function () {\n                //console.log('.h5p-iframe vollständig geladen.');\n                adjustParentIFrameHeight(); // Passe die Höhe an, wenn das iframe vollständig geladen ist\n                checkForH5P(); // Prüfe H5P erneut nach dem Laden\n                monitorElementLoads(); // Überwache das Laden von Elementen\n              });\n\n              // Fallback: Sofortiger Versuch, H5P zu finden\n              if (!checkForH5P()) {\n                //console.log(\"H5P wurde nicht gefunden, starte Überwachung.\");\n\n                // Fallback: Regelmäßige Überprüfung des Inhalts (Polling) für H5P\n                var h5pCheckInterval = setInterval(function () {\n                  if (checkForH5P()) {\n                    clearInterval(h5pCheckInterval); // Stoppe das Intervall, wenn H5P gefunden wurde\n                  }\n                }, 500); // Überprüft alle 500ms\n              }\n\n              return true; // nestedIFrame wurde gefunden, keine weitere Aktion erforderlich\n            }\n            return false; // nestedIFrame wurde noch nicht gefunden\n          };\n\n          // Initialer Versuch, nestedIFrame zu finden\n          if (!checkForNestedIFrame()) {\n            // console.log(\n            //     \"nestedIFrame wurde nicht gefunden, starte Beobachtung des parentIFrame.\"\n            // );\n\n            // Beobachte den parentIFrame für das Erscheinen des nestedIFrame\n            var observer = new MutationObserver(function (mutations) {\n              console.log(\"_hvpListener 7\");\n\n              mutations.forEach(function (mutation) {\n                if (mutation.addedNodes.length > 0) {\n                  // console.log(\n                  //     \"Eine neue Node wurde hinzugefügt:\",\n                  //     mutation.addedNodes\n                  // );\n                  if (checkForNestedIFrame()) {\n                    observer.disconnect(); // Stoppe das Beobachten, nachdem nestedIFrame gefunden wurde\n                  }\n                }\n              });\n            });\n\n            observer.observe(parentIFrameContent, {\n              childList: true,\n              subtree: true,\n            });\n          }\n        } else {\n          //console.error(\"Kein Dokument im parentIFrame gefunden.\");\n        }\n      });\n    } else {\n      //console.error(\"Keine parentIFrames gefunden.\");\n    }\n  }\n\n\n\n\n\n\n  // _hvpListener() {\n  //   var parentIFrames = this.getElements(this.selectors.H5P);\n  //   if (parentIFrames.length > 0) {\n  //     parentIFrames.forEach((parentIFrame) => {\n  //       if (parentIFrame.contentDocument) {\n  //         var parentIFrameContent =\n  //           parentIFrame.contentDocument || parentIFrame.contentWindow.document;\n\n  //         var nestedIFrame = parentIFrameContent.querySelector(\".h5p-iframe\");\n\n  //         if (nestedIFrame) {\n  //           var H5P = nestedIFrame.contentWindow.H5P;\n  //           if (H5P && H5P.externalDispatcher) {\n\n  //             // var nestedIFrameHeight =\n  //             // nestedIFrame.contentWindow.document.body.scrollHeight;\n  //             // parentIFrame.style.height = nestedIFrameHeight + \"px\";\n  //             //ILD.init(H5P);\n  //             window.console.log(H5P);\n\n  //             H5P.setFinished = function (contentId, score, maxScore, time) {\n  //              //hvp Funktion hijacken, damit die Grade nicht doppelt eingetragen wird\n  //             };\n  //             H5P.externalDispatcher.on(\"xAPI\", this._hvpprogress.bind(this));\n  //             var instance = H5P.instances[0];\n  //             H5P.trigger(instance, 'resize');\n  // var nestedIFrameHeight =\n  // nestedIFrame.contentWindow.document.body.scrollHeight;\n  // parentIFrame.style.height = nestedIFrameHeight + \"px\";\n  //           } else {\n  //             setTimeout(this._hvpListener.bind(this), 50);\n  //           }\n  //         } else {\n  //           setTimeout(this._hvpListener.bind(this), 50);\n  //         }\n  //       } else {\n  //         setTimeout(this._hvpListener.bind(this), 50);\n  //       }\n  //     });\n  //   }\n  // }\n\n  _hvpprogress(event) {\n    window.console.log(event);\n\n    if (event.getVerb() === \"completed\" || event.getVerb() === \"answered\") {\n      var contentId = event.getVerifiedStatementValue([\n        \"object\",\n        \"definition\",\n        \"extensions\",\n        \"http://h5p.org/x-api/h5p-local-content-id\",\n      ]);\n      var score = event.getScore();\n      var maxScore = event.getMaxScore();\n      var statement = event.data.statement;\n      var isChild =\n        statement.context &&\n        statement.context.contextActivities &&\n        statement.context.contextActivities.parent &&\n        statement.context.contextActivities.parent[0] &&\n        statement.context.contextActivities.parent[0].id;\n\n\n      this.reactive.dispatch(\n        \"updateSectionprogress\",\n        this.id,\n        contentId,\n        score,\n        maxScore\n      );\n\n    }\n  }\n}\n"],"names":["DndSection","create","name","selectors","SECTION_ITEM","CM","SECTIONINFO","SECTIONBADGES","SHOWSECTION","HIDESECTION","SETCHAPTER","UNSETCHAPTER","ACTIONTEXT","ICON","H5P","classes","LOCKED","HASDESCRIPTION","HIDE","HIDDEN","CHAPTER","id","this","element","dataset","stateReady","state","configState","reactive","isEditing","supportComponents","sectionItem","getElement","headerComponent","Header","fullregion","configDragDrop","_showLastSectionModal","_hvpListener","getWatchers","watch","handler","_refreshSection","validateDropData","dropdata","type","sectionReturn","super","getLastCm","cms","getElements","length","classList","toggle","DRAGGING","dragging","locked","visible","isChapter","sectioninfo","hasrestrictions","_updateBadges","_updateActionsMenu","title","innerHTML","prefix","section","current","hiddenFromStudents","selector","newAction","affectedAction","action","actionText","querySelector","swapname","oldText","innerText","icon","swapicon","newIcon","pixHtml","Templates","renderPix","replaceNode","get","showLastSectionModal","window","location","href","sectionurl","replace","modal","ModalFactory","Mooin4Modal","TYPE","body","render","footer","scrollable","show","showFooter","dispatch","h5p_contentIds","parentIFrames","forEach","parentIFrame","contentDocument","parentIFrameContent","contentWindow","document","nestedIFrame","adjustParentIFrameHeight","setTimeout","console","log","nestedIFrameHeight","scrollHeight","style","height","monitorElementLoads","tag","elements","getElementsByTagName","addEventListener","checkForH5P","H5PIntegration","externalDispatcher","setFinished","contentId","score","maxScore","time","includes","instances","array","push","init","MutationObserver","mutations","mutation","addedNodes","attributeName","observe","childList","subtree","attributes","checkForNestedIFrame","h5pCheckInterval","setInterval","clearInterval","observer","disconnect","_hvpprogress","event","getVerb","getVerifiedStatementValue","getScore","getMaxScore","statement","data","context","contextActivities","parent"],"mappings":"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"}