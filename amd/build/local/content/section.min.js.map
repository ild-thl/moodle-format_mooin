{"version":3,"file":"section.min.js","sources":["../../../src/local/content/section.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Course section format component.\n *\n * @module     core_courseformat/local/content/section\n * @class      core_courseformat/local/content/section\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Header from \"format_mooin4/local/content/section/header\";\nimport DndSection from \"format_mooin4/local/courseeditor/dndsection\";\nimport Templates from \"core/templates\";\nimport ModalFactory from \"core/modal_factory\";\nimport Mooin4Modal from \"../../mooin4modal\";\nimport { get_string as getString } from \"core/str\";\nimport ILD from \"format_mooin4/ildhvp4\";\n\nexport default class extends DndSection {\n  /**\n   * Constructor hook.\n   */\n  create() {\n    // Optional component name for debugging.\n    this.name = \"content_section\";\n    // Default query selectors.\n    this.selectors = {\n      SECTION_ITEM: `[data-for='section_title']`,\n      CM: `[data-for=\"cmitem\"]`,\n      SECTIONINFO: `[data-for=\"sectioninfo\"]`,\n      SECTIONBADGES: `[data-region=\"sectionbadges\"]`,\n      SHOWSECTION: `[data-action=\"sectionShow\"]`,\n      HIDESECTION: `[data-action=\"sectionHide\"]`,\n      SETCHAPTER: `[data-action=\"sectionSetChapter\"]`,\n      UNSETCHAPTER: `[data-action=\"sectionUnsetChapter\"]`,\n      ACTIONTEXT: `.menu-action-text`,\n      ICON: `.icon`,\n      H5P: `.parent-iframe`,\n    };\n    // Most classes will be loaded later by DndCmItem.\n    this.classes = {\n      LOCKED: \"editinprogress\",\n      HASDESCRIPTION: \"description\",\n      HIDE: \"d-none\",\n      HIDDEN: \"hidden\",\n      CHAPTER: \"chapter\",\n    };\n\n    // We need our id to watch specific events.\n    this.id = this.element.dataset.id;\n  }\n\n  /**\n   * Initial state ready method.\n   *\n   * @param {Object} state the initial state\n   */\n  stateReady(state) {\n    this.configState(state);\n    // Drag and drop is only available for components compatible course formats.\n    if (this.reactive.isEditing && this.reactive.supportComponents) {\n      // Section zero and other formats sections may not have a title to drag.\n      const sectionItem = this.getElement(this.selectors.SECTION_ITEM);\n      if (sectionItem) {\n        // Init the inner dragable element.\n        const headerComponent = new Header({\n          ...this,\n          element: sectionItem,\n          fullregion: this.element,\n        });\n        this.configDragDrop(headerComponent);\n      }\n    }\n    this._showLastSectionModal(state);\n    this._hvpListener();\n  }\n\n  /**\n   * Component watchers.\n   *\n   * @returns {Array} of watchers\n   */\n  getWatchers() {\n    return [\n      { watch: `section[${this.id}]:updated`, handler: this._refreshSection },\n      // {watch: `section[${this.id}].sectionprogress:updated`, handler: this._updateSectionProgress}\n    ];\n  }\n\n  /**\n   * Validate if the drop data can be dropped over the component.\n   *\n   * @param {Object} dropdata the exported drop data.\n   * @returns {boolean}\n   */\n  validateDropData(dropdata) {\n    // If the format uses one section per page sections dropping in the content is ignored.\n    if (dropdata?.type === \"section\" && this.reactive.sectionReturn != 0) {\n      return false;\n    }\n    return super.validateDropData(dropdata);\n  }\n\n  /**\n   * Get the last CM element of that section.\n   *\n   * @returns {element|null}\n   */\n  getLastCm() {\n    const cms = this.getElements(this.selectors.CM);\n    // DndUpload may add extra elements so :last-child selector cannot be used.\n    if (!cms || cms.length === 0) {\n      return null;\n    }\n    return cms[cms.length - 1];\n  }\n\n  /**\n   * Update a content section using the state information.\n   *\n   * @param {object} param\n   * @param {Object} param.element details the update details.\n   */\n  _refreshSection({ element }) {\n    // Update classes.\n    this.element.classList.toggle(\n      this.classes.DRAGGING,\n      element.dragging ?? false\n    );\n    this.element.classList.toggle(this.classes.LOCKED, element.locked ?? false);\n    this.element.classList.toggle(\n      this.classes.HIDDEN,\n      !element.visible ?? false\n    );\n    this.element.classList.toggle(\n      this.classes.CHAPTER,\n      element.isChapter ?? false\n    );\n    this.locked = element.locked;\n    // The description box classes depends on the section state.\n    const sectioninfo = this.getElement(this.selectors.SECTIONINFO);\n    if (sectioninfo) {\n      sectioninfo.classList.toggle(\n        this.classes.HASDESCRIPTION,\n        element.hasrestrictions\n      );\n    }\n    // Update section badges and menus.\n    this._updateBadges(element);\n    this._updateActionsMenu(element);\n\n    if (this.reactive.isEditing) {\n      //this._reloadSectionNames({ element: element });\n    }\n  }\n\n  async _reloadSectionNames({ element }) {\n    const title = this.getElement(this.selectors.SECTION_ITEM);\n    //window.console.log(element);\n    if (!element.isChapter) {\n      //title.innerHTML = element.parentChapter + \".\" + element.innerChapterNumber + \": \" + element.title;\n      title.innerHTML = element.prefix;\n    }\n  }\n\n  /**\n   * Update a section badges using the state information.\n   *\n   * @param {object} section the section state.\n   */\n  _updateBadges(section) {\n    const current = this.getElement(\n      `${this.selectors.SECTIONBADGES} [data-type='iscurrent']`\n    );\n    current?.classList.toggle(this.classes.HIDE, !section.current);\n\n    const hiddenFromStudents = this.getElement(\n      `${this.selectors.SECTIONBADGES} [data-type='hiddenfromstudents']`\n    );\n    hiddenFromStudents?.classList.toggle(this.classes.HIDE, section.visible);\n  }\n\n  /**\n   * Update a section action menus.\n   *\n   * @param {object} section the section state.\n   */\n  async _updateActionsMenu(section) {\n    let selector;\n    let newAction;\n    if (section.visible) {\n      selector = this.selectors.SHOWSECTION;\n      newAction = \"sectionHide\";\n    } else {\n      selector = this.selectors.HIDESECTION;\n      newAction = \"sectionShow\";\n    }\n\n    if (section.isChapter) {\n      selector = this.selectors.SETCHAPTER;\n      newAction = \"sectionUnsetChapter\";\n    } else {\n      selector = this.selectors.UNSETCHAPTER;\n      newAction = \"sectionSetChapter\";\n    }\n\n    // Find the affected action.\n    const affectedAction = this.getElement(selector);\n    if (!affectedAction) {\n      return;\n    }\n    // Change action.\n    affectedAction.dataset.action = newAction;\n    // Change text.\n    const actionText = affectedAction.querySelector(this.selectors.ACTIONTEXT);\n    if (affectedAction.dataset?.swapname && actionText) {\n      const oldText = actionText?.innerText;\n      actionText.innerText = affectedAction.dataset.swapname;\n      affectedAction.dataset.swapname = oldText;\n    }\n    // Change icon.\n    const icon = affectedAction.querySelector(this.selectors.ICON);\n    if (affectedAction.dataset?.swapicon && icon) {\n      const newIcon = affectedAction.dataset.swapicon;\n      if (newIcon) {\n        const pixHtml = await Templates.renderPix(newIcon, \"core\");\n        Templates.replaceNode(icon, pixHtml, \"\");\n      }\n    }\n  }\n\n  async _showLastSectionModal(state) {\n    const section = state.section.get(this.id);\n    if (\n      section.showLastSectionModal &&\n      window.location.href == section.sectionurl.replace(/&amp;/g, \"&\")\n    ) {\n      const modal = await ModalFactory.create({\n        type: Mooin4Modal.TYPE,\n        title: await getString(\n          \"modal_last_section_of_chapter_title\",\n          \"format_mooin4\"\n        ),\n        body: Templates.render(\n          \"format_mooin4/local/content/modals/lastsection\",\n          {}\n        ),\n        footer: Templates.render(\n          \"format_mooin4/local/content/modals/modalfooterclose\",\n          {}\n        ),\n        scrollable: false,\n      });\n      modal.show();\n      modal.showFooter();\n      this.reactive.dispatch(\"setLastSectionModal\", this.id);\n    }\n  }\n\n  _hvpListener() {\n    var parentIFrames = this.getElements(this.selectors.H5P);\n    //console.log(\"Anzahl der parentIFrames gefunden:\", parentIFrames.length);\n    if (parentIFrames.length > 0) {\n        parentIFrames.forEach((parentIFrame) => {\n            if (parentIFrame.contentDocument) {\n                var parentIFrameContent =\n                    parentIFrame.contentDocument || parentIFrame.contentWindow.document;\n                //console.log(\"parentIFrameContent gefunden:\", parentIFrameContent);\n\n                let nestedIFrame = null;\n\n                const adjustParentIFrameHeight = () => {\n                    setTimeout(() => {\n                        if (nestedIFrame && nestedIFrame.contentWindow.document.body) {\n                            const nestedIFrameHeight =\n                                nestedIFrame.contentWindow.document.body.scrollHeight;\n                            if (nestedIFrameHeight > 1) {\n                                parentIFrame.style.height = nestedIFrameHeight + \"px\";\n                                // console.log(\n                                //     \"ParentIFrame-Höhe angepasst:\",\n                                //     nestedIFrameHeight + \"px\"\n                                // );\n                            } else {\n                                //console.log(\"Inhalt noch nicht vollständig gerendert, Höhe nicht angepasst.\");\n                            }\n                        } else {\n                            //console.log(\"Body ist noch nicht verfügbar.\");\n                        }\n                    }, 100);\n                };\n\n                const monitorElementLoads = () => {\n                    // Überwache das Laden von Bildern, Videos und anderen Medien im iframe\n                    const elementsToWatch = ['img', 'video', 'iframe', 'embed', 'object'];\n                    elementsToWatch.forEach(tag => {\n                        const elements = nestedIFrame.contentDocument.getElementsByTagName(tag);\n                        for (let element of elements) {\n                            element.addEventListener('load', adjustParentIFrameHeight);\n                            element.addEventListener('resize', adjustParentIFrameHeight);\n                        }\n                    });\n                };\n\n                const checkForH5P = () => {\n                    if (nestedIFrame) {\n                      var H5PIntegration = nestedIFrame.contentWindow.H5PIntegration;\n                        var H5P = nestedIFrame.contentWindow.H5P;\n                        if (H5P && H5P.externalDispatcher) {\n                            //console.log(\"H5P-Objekt gefunden.\");\n\n                            H5P.setFinished = function (contentId, score, maxScore, time) {\n                                // H5P-Funktion hijacken, damit die Grade nicht doppelt eingetragen wird\n                            };\n\n                            //H5P.externalDispatcher.on(\"xAPI\", this._hvpprogress.bind(this));\n                            //ILD.checkLibrary();\n                            //H5P.externalDispatcher.on(\"xAPI\", ILD.xAPIAnsweredListener);\n                            ILD.init(H5P, H5PIntegration, this.id, this.reactive);\n                            //window.console.log(H5P);\n                            \n                            adjustParentIFrameHeight(); // Höhe sofort anpassen, wenn H5P gefunden wird\n\n                            // Starte den MutationObserver\n                            var observer = new MutationObserver(function (mutations) {\n                                mutations.forEach(function (mutation) {\n                                    if (mutation.addedNodes.length > 0 || mutation.attributeName === 'src') {\n                                        // console.log(\n                                        //     \"DOM-Änderung oder Attributänderung erkannt im .h5p-iframe: \",\n                                        //     mutation\n                                        // );\n                                        adjustParentIFrameHeight(); // Passe die Höhe nach der Mutation oder Attributänderung an\n                                    }\n                                });\n                            });\n\n                            observer.observe(nestedIFrame.contentDocument, {\n                                childList: true,\n                                subtree: true,\n                                attributes: true, // Überwacht Änderungen an Attributen wie `src`\n                            });\n                            // console.log(\n                            //     \"MutationObserver wurde gestartet, um Änderungen im .h5p-iframe zu überwachen.\"\n                            // );\n\n                            return true; // H5P wurde gefunden und alles eingerichtet\n                        }\n                    }\n                    return false; // H5P wurde noch nicht gefunden oder nestedIFrame ist nicht verfügbar\n                };\n\n                const checkForNestedIFrame = () => {\n                    nestedIFrame = parentIFrameContent.querySelector(\".h5p-iframe\");\n                    //console.log(\"nestedIFrame gefunden:\", nestedIFrame);\n\n                    if (nestedIFrame) {\n                        // Füge ein 'load' Event hinzu\n                        nestedIFrame.addEventListener('load', function() {\n                            //console.log('.h5p-iframe vollständig geladen.');\n                            adjustParentIFrameHeight(); // Passe die Höhe an, wenn das iframe vollständig geladen ist\n                            checkForH5P(); // Prüfe H5P erneut nach dem Laden\n                            monitorElementLoads(); // Überwache das Laden von Elementen\n                        });\n\n                        // Fallback: Sofortiger Versuch, H5P zu finden\n                        if (!checkForH5P()) {\n                            //console.log(\"H5P wurde nicht gefunden, starte Überwachung.\");\n\n                            // Fallback: Regelmäßige Überprüfung des Inhalts (Polling) für H5P\n                            var h5pCheckInterval = setInterval(function () {\n                                if (checkForH5P()) {\n                                    clearInterval(h5pCheckInterval); // Stoppe das Intervall, wenn H5P gefunden wurde\n                                }\n                            }, 500); // Überprüft alle 500ms\n                        }\n\n                        return true; // nestedIFrame wurde gefunden, keine weitere Aktion erforderlich\n                    }\n                    return false; // nestedIFrame wurde noch nicht gefunden\n                };\n\n                // Initialer Versuch, nestedIFrame zu finden\n                if (!checkForNestedIFrame()) {\n                    // console.log(\n                    //     \"nestedIFrame wurde nicht gefunden, starte Beobachtung des parentIFrame.\"\n                    // );\n\n                    // Beobachte den parentIFrame für das Erscheinen des nestedIFrame\n                    var observer = new MutationObserver(function (mutations) {\n                        mutations.forEach(function (mutation) {\n                            if (mutation.addedNodes.length > 0) {\n                                // console.log(\n                                //     \"Eine neue Node wurde hinzugefügt:\",\n                                //     mutation.addedNodes\n                                // );\n                                if (checkForNestedIFrame()) {\n                                    observer.disconnect(); // Stoppe das Beobachten, nachdem nestedIFrame gefunden wurde\n                                }\n                            }\n                        });\n                    });\n\n                    observer.observe(parentIFrameContent, {\n                        childList: true,\n                        subtree: true,\n                    });\n                }\n            } else {\n                //console.error(\"Kein Dokument im parentIFrame gefunden.\");\n            }\n        });\n    } else {\n        //console.error(\"Keine parentIFrames gefunden.\");\n    }\n}\n\n\n\n\n\n\n  // _hvpListener() {\n  //   var parentIFrames = this.getElements(this.selectors.H5P);\n  //   if (parentIFrames.length > 0) {\n  //     parentIFrames.forEach((parentIFrame) => {\n  //       if (parentIFrame.contentDocument) {\n  //         var parentIFrameContent =\n  //           parentIFrame.contentDocument || parentIFrame.contentWindow.document;\n\n  //         var nestedIFrame = parentIFrameContent.querySelector(\".h5p-iframe\");\n\n  //         if (nestedIFrame) {\n  //           var H5P = nestedIFrame.contentWindow.H5P;\n  //           if (H5P && H5P.externalDispatcher) {\n\n  //             // var nestedIFrameHeight =\n  //             // nestedIFrame.contentWindow.document.body.scrollHeight;\n  //             // parentIFrame.style.height = nestedIFrameHeight + \"px\";\n  //             //ILD.init(H5P);\n  //             window.console.log(H5P);\n\n  //             H5P.setFinished = function (contentId, score, maxScore, time) {\n  //              //hvp Funktion hijacken, damit die Grade nicht doppelt eingetragen wird\n  //             };\n  //             H5P.externalDispatcher.on(\"xAPI\", this._hvpprogress.bind(this));\n  //             var instance = H5P.instances[0];\n  //             H5P.trigger(instance, 'resize');\n  // var nestedIFrameHeight =\n  // nestedIFrame.contentWindow.document.body.scrollHeight;\n  // parentIFrame.style.height = nestedIFrameHeight + \"px\";\n  //           } else {\n  //             setTimeout(this._hvpListener.bind(this), 50);\n  //           }\n  //         } else {\n  //           setTimeout(this._hvpListener.bind(this), 50);\n  //         }\n  //       } else {\n  //         setTimeout(this._hvpListener.bind(this), 50);\n  //       }\n  //     });\n  //   }\n  // }\n\n  _hvpprogress(event) {\n    window.console.log(event);\n\n    if (event.getVerb() === \"completed\" || event.getVerb() === \"answered\") {\n      var contentId = event.getVerifiedStatementValue([\n        \"object\",\n        \"definition\",\n        \"extensions\",\n        \"http://h5p.org/x-api/h5p-local-content-id\",\n      ]);\n      var score = event.getScore();\n      var maxScore = event.getMaxScore();\n      var statement = event.data.statement;\n      var isChild =\n        statement.context &&\n        statement.context.contextActivities &&\n        statement.context.contextActivities.parent &&\n        statement.context.contextActivities.parent[0] &&\n        statement.context.contextActivities.parent[0].id;\n\n      \n        this.reactive.dispatch(\n          \"updateSectionprogress\",\n          this.id,\n          contentId,\n          score,\n          maxScore\n        );\n      \n    }\n  }\n}\n"],"names":["DndSection","create","name","selectors","SECTION_ITEM","CM","SECTIONINFO","SECTIONBADGES","SHOWSECTION","HIDESECTION","SETCHAPTER","UNSETCHAPTER","ACTIONTEXT","ICON","H5P","classes","LOCKED","HASDESCRIPTION","HIDE","HIDDEN","CHAPTER","id","this","element","dataset","stateReady","state","configState","reactive","isEditing","supportComponents","sectionItem","getElement","headerComponent","Header","fullregion","configDragDrop","_showLastSectionModal","_hvpListener","getWatchers","watch","handler","_refreshSection","validateDropData","dropdata","type","sectionReturn","super","getLastCm","cms","getElements","length","classList","toggle","DRAGGING","dragging","locked","visible","isChapter","sectioninfo","hasrestrictions","_updateBadges","_updateActionsMenu","title","innerHTML","prefix","section","current","hiddenFromStudents","selector","newAction","affectedAction","action","actionText","querySelector","swapname","oldText","innerText","icon","swapicon","newIcon","pixHtml","Templates","renderPix","replaceNode","get","showLastSectionModal","window","location","href","sectionurl","replace","modal","ModalFactory","Mooin4Modal","TYPE","body","render","footer","scrollable","show","showFooter","dispatch","parentIFrames","forEach","parentIFrame","contentDocument","parentIFrameContent","contentWindow","document","nestedIFrame","adjustParentIFrameHeight","setTimeout","nestedIFrameHeight","scrollHeight","style","height","monitorElementLoads","tag","elements","getElementsByTagName","addEventListener","checkForH5P","H5PIntegration","externalDispatcher","setFinished","contentId","score","maxScore","time","init","MutationObserver","mutations","mutation","addedNodes","attributeName","observe","childList","subtree","attributes","checkForNestedIFrame","h5pCheckInterval","setInterval","clearInterval","observer","disconnect","_hvpprogress","event","console","log","getVerb","getVerifiedStatementValue","getScore","getMaxScore","statement","data","context","contextActivities","parent"],"mappings":"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"}